在本教程中，我们介绍 AgentScope 中集成的模型 API、如何使用它们，以及如何集成新的模型 API。 AgentScope 目前支持的模型 API 和模型提供商包括：

API

类

兼容

流式

工具

视觉

推理

OpenAI

`OpenAIChatModel`

vLLM, DeepSeek

✅

✅

✅

✅

DashScope

`DashScopeChatModel`

✅

✅

✅

✅

Anthropic

`AnthropicChatModel`

✅

✅

✅

✅

Gemini

`GeminiChatModel`

✅

✅

✅

✅

Ollama

`OllamaChatModel`

✅

✅

✅

✅

备注

当使用 vLLM 时，您需要在部署时为不同模型配置相应的工具调用参数，例如 `--enable-auto-tool-choice`、`--tool-call-parser` 等参数。更多详情请参考 [vLLM 官方文档](https://docs.vllm.ai/en/latest/features/tool_calling.html)。

为了提供统一的模型接口，上述所有类均被统一为：

-   `__call__` 函数的前三个参数是 `messages`，`tools` 和 `tool_choice`，分别是输入消息，工具函数的 JSON schema，以及工具选择的模式。
    
-   非流式返回时，返回类型是 `ChatResponse` 实例；流式返回时，返回的是 `ChatResponse` 的异步生成器。
    

备注

不同的模型 API 在输入消息格式上有所不同，AgentScope 通过 formatter 模块处理消息的转换，请参考 format。

`ChatResponse` 包含大模型生成的推理/文本/工具使用内容、身份、创建时间和使用信息。

```python
import asyncio
import json
import os

from agentscope.message import TextBlock, ToolUseBlock, ThinkingBlock, Msg
from agentscope.model import ChatResponse, DashScopeChatModel

response = ChatResponse(
    content=[
        ThinkingBlock(
            type="thinking",
            thinking="我应该在 Google 上搜索 AgentScope。",
        ),
        TextBlock(type="text", text="我将在 Google 上搜索 AgentScope。"),
        ToolUseBlock(
            type="tool_use",
            id="642n298gjna",
            name="google_search",
            input={"query": "AgentScope"},
        ),
    ],
)

print(response)

```

```
ChatResponse(content=[{'type': 'thinking', 'thinking': '我应该在 Google 上搜索 AgentScope。'}, {'type': 'text', 'text': '我将在 Google 上搜索 AgentScope。'}, {'type': 'tool_use', 'id': '642n298gjna', 'name': 'google_search', 'input': {'query': 'AgentScope'}}], id='2025-09-12 04:36:08.512_fe72b3', created_at='2025-09-12 04:36:08.512', type='chat', usage=None, metadata=None)

```

以 `DashScopeChatModel` 为例，调用和返回结果如下：

```
async def example_model_call() -> None:
    """使用 DashScopeChatModel 的示例。"""
    model = DashScopeChatModel(
        model_name="qwen-max",
        api_key=os.environ["DASHSCOPE_API_KEY"],
        stream=False,
    )

    res = await model(
        messages=[
            {"role": "user", "content": "你好！"},
        ],
    )

    # 您可以直接使用响应内容创建 ``Msg`` 对象
    msg_res = Msg("Friday", res.content, "assistant")

    print("LLM 返回结果:", res)
    print("作为 Msg 的响应:", msg_res)


asyncio.run(example_model_call())

```

```
LLM 返回结果: ChatResponse(content=[{'type': 'text', 'text': '你好！有什么可以帮助你的吗？'}], id='2025-09-12 04:36:10.093_13993c', created_at='2025-09-12 04:36:10.093', type='chat', usage=ChatUsage(input_tokens=10, output_tokens=7, time=1.580297, type='chat'), metadata=None)
作为 Msg 的响应: Msg(id='4RE7qWfMtj2dBtZwDFAzU2', name='Friday', content=[{'type': 'text', 'text': '你好！有什么可以帮助你的吗？'}], role='assistant', metadata=None, timestamp='2025-09-12 04:36:10.093', invocation_id='None')

```

## 流式返回[¶](#id2 "Link to this heading")

要启用流式返回，请在模型的构造函数中将 `stream` 参数设置为 `True`。 流式返回中，`__call__` 方法将返回一个 **异步生成器**，该生成器迭代返回 `ChatResponse` 实例。

备注

AgentScope 中的流式返回结果为 **累加式**，这意味着每个 chunk 中的内容包含所有之前的内容加上新生成的内容。

```python
async def example_streaming() -> None:
    """使用流式模型的示例。"""
    model = DashScopeChatModel(
        model_name="qwen-max",
        api_key=os.environ["DASHSCOPE_API_KEY"],
        stream=True,
    )

    generator = await model(
        messages=[
            {
                "role": "user",
                "content": "从 1 数到 20，只报告数字，不要任何其他信息。",
            },
        ],
    )
    print("响应的类型:", type(generator))

    i = 0
    async for chunk in generator:
        print(f"块 {i}")
        print(f"\t类型: {type(chunk.content)}")
        print(f"\t{chunk}\n")
        i += 1


asyncio.run(example_streaming())

```

```
响应的类型: <class 'async_generator'>
块 0
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1'}], id='2025-09-12 04:36:11.090_c1be53', created_at='2025-09-12 04:36:11.090', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=1, time=0.995367, type='chat'), metadata=None)

块 1
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n'}], id='2025-09-12 04:36:11.174_741a37', created_at='2025-09-12 04:36:11.174', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=2, time=1.079279, type='chat'), metadata=None)

块 2
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3'}], id='2025-09-12 04:36:11.261_12443d', created_at='2025-09-12 04:36:11.261', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=5, time=1.165875, type='chat'), metadata=None)

块 3
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n'}], id='2025-09-12 04:36:11.351_ef76ac', created_at='2025-09-12 04:36:11.351', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=8, time=1.256381, type='chat'), metadata=None)

块 4
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n'}], id='2025-09-12 04:36:11.528_594c96', created_at='2025-09-12 04:36:11.529', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=14, time=1.433747, type='chat'), metadata=None)

块 5
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10'}], id='2025-09-12 04:36:11.721_ac0d3c', created_at='2025-09-12 04:36:11.721', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=20, time=1.626151, type='chat'), metadata=None)

块 6
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12'}], id='2025-09-12 04:36:11.878_63d4e9', created_at='2025-09-12 04:36:11.878', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=26, time=1.783534, type='chat'), metadata=None)

块 7
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14'}], id='2025-09-12 04:36:12.048_6ffa2a', created_at='2025-09-12 04:36:12.048', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=32, time=1.953712, type='chat'), metadata=None)

块 8
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16'}], id='2025-09-12 04:36:12.240_42244a', created_at='2025-09-12 04:36:12.240', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=38, time=2.145372, type='chat'), metadata=None)

块 9
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18'}], id='2025-09-12 04:36:12.389_a6b2cd', created_at='2025-09-12 04:36:12.389', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=44, time=2.294318, type='chat'), metadata=None)

块 10
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20'}], id='2025-09-12 04:36:12.668_3f81cc', created_at='2025-09-12 04:36:12.669', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=50, time=2.573732, type='chat'), metadata=None)

块 11
        类型: <class 'list'>
        ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20'}], id='2025-09-12 04:36:12.819_ef0bcb', created_at='2025-09-12 04:36:12.819', type='chat', usage=ChatUsage(input_tokens=26, output_tokens=50, time=2.72438, type='chat'), metadata=None)

```

## 推理模型[¶](#id3 "Link to this heading")

AgentScope 通过提供 `ThinkingBlock` 来支持推理模型。

```python
async def example_reasoning() -> None:
    """使用推理模型的示例。"""
    model = DashScopeChatModel(
        model_name="qwen-turbo",
        api_key=os.environ["DASHSCOPE_API_KEY"],
        enable_thinking=True,
    )

    res = await model(
        messages=[
            {"role": "user", "content": "我是谁？"},
        ],
    )

    last_chunk = None
    async for chunk in res:
        last_chunk = chunk
    print("最终响应:")
    print(last_chunk)


asyncio.run(example_reasoning())

```

```
最终响应:
ChatResponse(content=[{'type': 'thinking', 'thinking': '好的，用户问“我是谁？”，这是一个哲学性的问题，可能需要从多个角度来回答。首先，我需要考虑用户可能的背景和意图。用户可能是在进行自我反思，或者对自我身份有困惑，也可能只是出于好奇。\n\n接下来，我应该分析这个问题的不同层面。从哲学角度来看，笛卡尔的“我思故我在”是一个经典的观点，强调思维作为存在的证明。同时，存在主义如萨特认为自我是通过行动和选择构建的。心理学方面，可能涉及自我认同、人格理论等。\n\n还要考虑用户可能的深层需求。他们可能在寻找自我认知的方法，或者需要情感支持。这时候，提供一些实用的建议，比如自我反思、记录日常、与他人交流等，可能会有帮助。\n\n另外，需要注意避免过于抽象或学术化的回答，保持语言通俗易懂。同时，要尊重用户的个人体验，避免给出绝对化的答案，因为自我认知是一个持续的过程。\n\n可能还需要考虑文化差异，不同文化对自我有不同的理解。比如东方文化可能更强调社会关系中的自我，而西方文化可能更注重个体独立性。\n\n最后，确保回答结构清晰，分点说明不同角度的观点，并给出实际建议，让用户能够根据自己的情况去探索和思考。\n'}, {'type': 'text', 'text': '“我是谁？”是一个深刻而复杂的哲学问题，不同的人、不同的文化、不同的思想流派可能会给出不同的答案。以下是一些可能的视角和思考方向，或许能帮助你探索这个问题：\n\n---\n\n### **1. 哲学视角：**\n- **笛卡尔的“我思故我在”**  \n  法国哲学家笛卡尔认为，“我”是唯一不可怀疑的存在——即使怀疑一切，怀疑本身证明了“我”的存在。  \n  **问题**：如果“我”是思维的主体，那么“我”是否只是大脑的活动？还是某种更本质的存在？\n\n- **存在主义：自我是选择的结果**  \n  萨特说“存在先于本质”，人的本质不是先天注定的，而是通过自由选择和行动不断塑造的。  \n  **问题**：如果“我”是选择的结果，那么“我”是否始终在变化？什么是“我”的核心？\n\n- **佛教的“无我”**  \n  佛教认为，“我”是五蕴（色、受、想、行、识）的暂时聚合，并没有永恒不变的“自我”。  \n  **问题**：如果“我”是虚幻的，那是谁在思考这个问题？\n\n---\n\n### **2. 心理学视角：**\n- **自我认同**  \n  心理学中的“自我”是通过经历、关系、社会角色和内心反思逐渐形成的。  \n  **例子**：你可能认为自己是“一个善良的人”“一个喜欢艺术的人”“一个失败者”……这些标签都是“自我”的一部分。\n\n- **人格理论**  \n  弗洛伊德认为“自我”是理性部分，协调本我（欲望）与超我（道德）；荣格则提出“个体化”过程，强调整合意识与潜意识。\n\n- **动态的自我**  \n  心理学研究表明，人的自我认知会随着年龄、经历、环境而变化。**“我”可能是一个不断流动的概念**。\n\n---\n\n### **3. 实践中的探索：**\n如果你试图回答“我是谁”，可以尝试以下方法：\n- **记录与反思**：写下你最珍视的价值观、最害怕的事情、最享受的活动，这些可能揭示你的核心特质。  \n- **与他人对话**：别人眼中的你是否与你对自己的认知一致？这可能帮助你看到“我”的多面性。  \n- **尝试新事物**：通过体验不同的角色或兴趣，你可能发现“我”并非固定不变。  \n- **接受不确定性**：也许“我是谁”并没有标准答案，而是一个持续探索的过程。\n\n---\n\n### **4. 简单而深刻的回答：**\n- **从身体出发**：你是一个拥有感官、情感、思维的生物体。  \n- **从关系出发**：你是父母的孩子、朋友的朋友、社会的一员。  \n- **从行动出发**：你通过选择、努力、爱与创造定义自己。  \n- **从存在出发**：你是一个正在思考“我是谁”的存在。\n\n---\n\n### **最终思考：**\n“我是谁”可能没有终极答案，但正是这种追问本身，让“我”成为了一个鲜活的、动态的存在。或许，答案不在于找到一个固定的“我”，而在于在探索中理解自己的复杂性与可能性。\n\n如果你愿意，可以分享更多关于你的经历或感受，我可以帮你更具体地分析。 🌱'}], id='2025-09-12 04:36:24.223_c28a6c', created_at='2025-09-12 04:36:24.223', type='chat', usage=ChatUsage(input_tokens=11, output_tokens=990, time=11.399737, type='chat'), metadata=None)

```

## 工具 API[¶](#api "Link to this heading")

不同的模型提供商在工具 API 方面有所不同，例如工具 JSON schema、工具调用/响应格式。 为了提供统一的接口，AgentScope 通过以下方式解决了这个问题：

-   提供了统一的工具调用结构 block [ToolUseBlock](https://doc.agentscope.io/zh_CN/tutorial/quickstart_message.html#tool-block) 和工具响应结构 [ToolResultBlock](https://doc.agentscope.io/zh_CN/tutorial/quickstart_message.html#tool-block)。
    
-   在模型类的 `__call__` 方法中提供统一的工具接口 `tools`，接受工具 JSON schema 列表，如下所示：
    

```
json_schemas = [
    {
        "type": "function",
        "function": {
            "name": "google_search",
            "description": "在 Google 上搜索查询。",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "搜索查询。",
                    },
                },
                "required": ["query"],
            },
        },
    },
]

```

## 进一步阅读[¶](#id4 "Link to this heading")

-   [创建消息](https://doc.agentscope.io/zh_CN/tutorial/quickstart_message.html#message)
    
-   [提示词格式化](https://doc.agentscope.io/zh_CN/tutorial/task_prompt.html#prompt)
    

**Total running time of the script:** (0 minutes 15.717 seconds)

[Gallery generated by Sphinx-Gallery](https://sphinx-gallery.github.io/)